# AArch64 (Apple Silicon) Migration Plan for MINIX

This plan tracks the work required to bring up a functional AArch64 (arm64) port of MINIX that builds and runs under UEFI on Apple Silicon and QEMU’s `virt` machine. It’s organized in phases with concrete tasks and acceptance criteria.

## Build Issues (make apple-silicon 2025-08-31)

- [x] Missing AArch64 arch headers: the include phase descends into `minix/include/arch/aarch64`, which does not exist yet, causing a hard failure. This comes from unconditional MINIX include wiring in `include/Makefile:45` which always adds `../minix/include` when `__MINIX` is set.
      - Symptom: `sh: line 1: cd: minix/include/arch/aarch64: No such file or directory`
      - Action: gate MINIX include for AArch64 until headers land. Example: only add `../minix/include` when `${MACHINE_ARCH} != "aarch64"` or when `${MKMINIX} != "no"`.
      - Done: `include/Makefile` now adds `../minix/include` only when `${MACHINE_ARCH} != aarch64` and `MKMINIX != no`.
- [x] Malformed conditional in libsys: `minix/lib/libsys/makefile:109` tests `${MKPCI}` directly, which is undefined for AArch64, leading to a bmake parse error.
      - Symptom: `Malformed conditional (${MKPCI} != "no")`
      - Action: switch to `${USE_PCI}` or guard `${MKPCI}` with `defined(MKPCI)`. Example: `.if ${USE_PCI} != "no"` or `.if defined(MKPCI) && ${MKPCI} != "no"`.
      - Done: Guarded conditional as `(.if defined(USE_PCI) && ${USE_PCI} != "no") || (defined(MKPCI) && ${MKPCI} != "no")`).
- [x] Toolchain triple mismatch for AArch64: the build produces tools with the prefix `aarch64-elf32-minix-` due to `share/mk/bsd.own.mk:1080` forcing `-elf32-minix` for all MINIX builds.
      - Impact: wrong ABI naming for 64‑bit AArch64; will complicate linker/emulation selection and future runtime.
      - Action: teach `bsd.own.mk` to use `aarch64-elf64-minix` when `${MACHINE_ARCH} == aarch64`. Also update `releasetools/arm64_efi_image.sh` (`TOOLCHAIN_TRIPLET`) accordingly.
      - Done: `share/mk/bsd.own.mk` now sets `MACHINE_GNU_PLATFORM=${MACHINE_GNU_ARCH}-elf64-minix` on AArch64. `releasetools/arm64_efi_image.sh` sets `TOOLCHAIN_TRIPLET=aarch64-elf64-minix-`. `tools/binutils/Makefile` aliases aarch64-elf{32,64}-minix to `aarch64-elf` for configure.
- [x] Build target not skipping MINIX on AArch64: `Makefile:584` target `apple-silicon` runs `./build.sh ... -m evbarm64-el` without disabling the MINIX subtree, so the tree still descends into `minix/*` and fails early.
      - Action: pass `-V MKMINIX=no` to both `tools` and `distribution` invocations as a short‑term workaround, aligned with the top‑level gating intent. Long‑term: remove this once AArch64 MINIX headers and libsys exist.
      - Done: Added `-V MKMINIX=no` to both build.sh invocations in the `apple-silicon` target.

Plan updates based on the above:

- Phase 1 — Build System & Toolchain
  - [x] Add AArch64‑specific gating in `include/Makefile` to skip `../minix/include` when `${MACHINE_ARCH} == aarch64` or when `MKMINIX=no`.
  - [x] Replace unguarded `MK*` checks in MINIX userland makefiles with `USE_*` (e.g., `USE_PCI`) or `defined()` guards; start with `minix/lib/libsys/makefile`.
  - [x] Set `MACHINE_GNU_PLATFORM` to `aarch64-elf64-minix` for AArch64 in `share/mk/bsd.own.mk` and propagate to image tools.
- Convenience target
  - [x] Update `apple-silicon` to add `-V MKMINIX=no` to both `build.sh` lines to allow NetBSD userland + image scaffolding to complete pending AArch64 MINIX.

## Phase 0 — Orientation & Scope

- [x] Define ABI and target triple
  - Chosen ABI: LP64 AArch64 ELF (little‑endian)
  - Canonical target triple: `aarch64-elf64-minix`
  - Register conventions (AAPCS64):
    - Argument/result: `x0..x7` (integer/pointer), `v0..v7` (FP/SIMD)
    - Return: `x0` (primary), `x1` (secondary), `v0` for FP
    - Callee‑saved: `x19..x28`, `x29` (FP), `x30` (LR), `sp`; FP callee‑saved: `v8..v15`
  - Stack: 16‑byte aligned at all public call boundaries; red zone: none
  - Syscall ABI (userspace trap shim used by libsys):
    - Instruction: `svc #0`
    - Number: `x8`; args in `x0..x5`; result in `x0`; error as negative errno in `x0`
  - TLS: ELF TLS; use General Dynamic/Local Dynamic for shared objects, Initial Exec for libc, Local Exec for kernel and statically linked pieces
  - Relocations: ELF64 AArch64 (RELA only); PIE for userland, static for kernel/modules initially

- [x] Identify boot strategy under UEFI
  - Strategy: GRUB 2 (arm64 EFI) invoking a Multiboot‑compatible MINIX kernel
  - Minimal loader spec:
    - ESP contains `/boot/efi/grub.cfg` generated by `create_grub_cfg_arm64()`
    - Kernel path: `/boot/minix_default/kernel`
    - Modules: `/boot/minix_default/mod01_ds .. mod12_init` (ordered)
    - GRUB stanza (arm64): `multiboot /boot/minix_default/kernel <args>` then `module` lines for each component
    - Console and root can be passed via kernel args; memory map via multiboot info
  - Current status: `releasetools/image.functions` provides `create_grub_cfg_arm64()` and `arm64_efi_image.sh` installs it on the ESP

## Phase 1 — Build System & Toolchain

- [x] Update build system target triple
  - Done: `share/mk/bsd.own.mk` sets `MACHINE_GNU_PLATFORM=${MACHINE_GNU_ARCH}-elf64-minix` for AArch64; preserves existing `MACHINE_GNU_ARCH` logic.

- [x] Binutils support for the triple
  - Done: `tools/binutils/Makefile` aliases `aarch64-elf{32,64}-minix` to `aarch64-elf` for configure while keeping install prefix as `aarch64-elf64-minix-*`.
  - Emulation: reuse generic AArch64 ELF emulation for now.
  - Acceptance: to verify by building `aarch64-elf64-minix-{objcopy,ld,nm,strip}` via `make apple-silicon` tools stage.

- [x] Compiler (GCC/Clang) support
  - Done: AArch64 LLVM targets are present; `share/mk/bsd.own.mk` now injects `-target ${MACHINE_GNU_PLATFORM}` for non-host clang when building AArch64, complementing prefixed cross wrappers.
  - Builtins: libc build is already wired to compiler_rt on AArch64 via `_LIBC_COMPILER_RT.aarch64=yes`.
  - Acceptance: compile a trivial hello (object-only) with `${TOOLDIR}/bin/aarch64-elf64-minix-clang`; full link will follow after Phase 2 libc.

- [x] Host tools parity on macOS
  - Done: Added `releasetools/check_aarch64_tools.sh` to verify presence of key cross tools in tooldir on macOS arm64 after the tools stage.
  - Usage: run after `make apple-silicon` tools stage to confirm `aarch64-elf64-minix-{clang,binutils}` wrappers exist.

## Phase 2 — Arch Headers & libc glue

- [ ] Create `minix/include/arch/aarch64/include/`
  - Initial files: `archconst.h`, `archtypes.h`, `elf.h`, `ipcconst.h`, `memory.h`, `partition.h`, `stackframe.h`, `vm.h`.
  - Derive from `earm` and adjust for AArch64 LP64 sizes and ABI.
- [ ] libc arch shims
  - Wire up signal trampolines, setjmp/longjmp, errno/PSR access if needed.
  - Acceptance: libc for AArch64 compiles for the MINIX sysroot.
- [ ] Remove temporary header workarounds
  - Comment out the i386 fallback include from `minix/commands/partition/Makefile` once `arch/aarch64` exists.

## Phase 3 — libsys (system call ABI)

- [ ] Implement syscall stubs/trampolines for AArch64
  - Add `syscall`/SVC entry glue; parameter passing via x0‑x7; error returns in x0 with carry semantics as needed.
  - Context save/restore helpers, userland entry sequences, thread‑local storage setup.
  - Acceptance: basic syscalls link and a trivial program invoking `_exit(0)` runs under QEMU when the kernel lands.

## Phase 4 — Kernel Bring‑up (arch/aarch64)

- [ ] Directory and core files
  - `minix/kernel/arch/aarch64/`: `head.S`, exception vector table, `exception.c`, `klib.S`, `mpx.S` analogs, `procoffsets.cf`, `kernel.lds` for AArch64.
- [ ] MMU & paging
  - Early page tables (TTBRs), memory map, identity map for early boot, switch to kernel VA layout.
- [ ] Interrupts & timer
  - GICv2/v3 support (start with GICv2 on QEMU virt), generic ARM timer (cntvct/cnthp), IRQ routing.
- [ ] Device tree (FDT) support
  - Integrate libfdt and parse QEMU/UEFI-provided DTBs for hardware discovery.
  - Mirrors NetBSD's GENERIC64 approach using 64-bit device trees to span multiple boards.
- [ ] Context switching & traps
  - User/kernel mode transitions, signal delivery/return, copyin/copyout.
- [ ] SMP (optional later)
  - PSCI bring‑up for secondary cores; initial target can be UP.
  - Acceptance: kernel enters main, prints banner on PL011, handles timer interrupts, and idles.

## Phase 5 — Platform/Board Support

- [ ] QEMU `virt` machine as the reference platform
  - Drivers: PL011 UART for console, virtio‑blk, virtio‑net (later), generic RTC if needed.
  - Use `qemu-system-aarch64 -M virt` as the baseline emulation command.
  - PSCI for power management calls.
- [ ] Apple Silicon Parallels VM profile
  - Validate UEFI boot, expose virtio devices similarly; confirm console path.
  - Acceptance: serial console output visible; virtio‑blk used for rootfs.

## Phase 6 — Servers & Drivers Audit

- [ ] Audit servers for 64‑bit assumptions
  - `rs`, `pm`, `vfs`, `vm`, `ds`, `sched`, `mib`, etc. Fix size_t/ptrdiff_t and pointer truncation issues.
- [ ] Drivers
  - TTY via PL011; block via virtio‑blk; network via virtio‑net (post‑MVP).
  - Acceptance: minimal single‑user boot to shell on a RAM disk or virtio disk.

## Phase 7 — Boot Loader Path (UEFI)

- [ ] Decide and implement loader
  - Option A: GRUB arm64 with a MINIX loader module (Multiboot‑like handoff) — requires writing a loader that prepares bootinfo and loads modules.
  - Option B: Custom EFI app that locates and loads the MINIX ELF kernel and modules and sets up a bootinfo structure.
- [ ] Image builder adaptations
  - Update `releasetools/arm64_efi_image.sh` and `image.functions` to write the correct loader and config (GRUB cfg or start.efi) for AArch64.
  - Include a 64-bit `virt.dtb` in EFI images and ensure the loader passes it to the kernel.
  - Acceptance: `minix_arm64_efi.img` boots to the MINIX kernel on QEMU/Parallels.

## Phase 8 — Distribution & Sets

- [ ] Remove the `MKMINIX=no` gating for AArch64
  - Enable the Minix subtree for `evbarm64*` once kernel+userland build.
- [ ] Sets composition
  - Add AArch64 to sets lists; ensure `minix-base`, `minix-comp`, `minix-man`, etc., include AArch64 outputs.
- [ ] Release tools
  - Confirm `releasetools/` scripts handle AArch64 (paths, partitions, sizes). Adjust `image.defaults` for arm64 naming and sizes.
  - Acceptance: `./build.sh -m evbarm64-el distribution` produces complete sets including kernel (`minix-kernel.tgz`).

## Phase 9 — Testing & CI

- [ ] QEMU smoke tests
  - Boot image non‑interactively to a shell; verify simple commands; run a sanity test suite.
- [ ] Parallels validation
  - Produce a VM template; verify console, disk, and network (virtio/net if available).
- [ ] Automated builds on macOS (arm64)
  - Scripted toolchain + userland + image build; retain logs/artifacts.
- [ ] Automated QEMU tests with anita
  - Adapt NetBSD's anita harness to boot arm64 images and capture console output.

## Phase 10 — Cleanup & Hardening

- [ ] Remove temporary workarounds
  - Revert i386 partition header fallbacks; drop zero‑decls in `installboot` once those arches are included or conditionally compiled.
- [ ] Documentation
  - Update README with AArch64 build/run instructions; add troubleshooting.
- [ ] Performance & robustness
  - Enable SMP; tune timers; review memory map; audit cache/TLB barriers in context switches and drivers.

## Current Repo Deltas (Already Applied)

- Binutils: target aliasing for AArch64; forced reconfigure when changed.
- Host fixes on macOS: compat headers, texinfo includes.
- Installboot linking: declared missing `ib_mach_*` to unblock host tool.
- Partition host include fallback for aarch64 (temporary).
- `apple-silicon` target and ARM64 EFI image builder (scaffold mode).
- Makefile gating to optionally skip Minix subtree on AArch64 for NetBSD userland reference builds.

## Acceptance Milestones

1. Cross‑tools + NetBSD userland build for `evbarm64-el` (reference only).
2. MINIX libc+libsys compile and link for AArch64.
3. Kernel boots to single user on QEMU `virt` with PL011 console.
4. Boot from `minix_arm64_efi.img` under UEFI (GRUB/custom loader) with modules.
5. Multi‑user bring‑up with storage (virtio‑blk) and TTY.
6. Parallels validation; docs complete; nightly CI green.

## Notes & Constraints

- We will keep using Clang/LLD where possible on macOS; binutils/BFD are built for the cross target only.
- If GRUB path becomes burdensome on arm64, pivot to a tiny custom EFI loader for MINIX.
- Keep changes minimal and gated to AArch64 until the port matures; do not regress i386/earm.
